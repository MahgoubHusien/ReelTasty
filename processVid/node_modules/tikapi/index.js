var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import API from "./api.js";
import * as fs from 'fs/promises';
const TikAPI = (apiKey) => {
    if (!apiKey) {
        throw new Error("The API Key is required.");
    }
    const on_success = function (res, req) {
        /**
        * A convenient method to get the next batch of items, if the endpoint has iteration parameters (e.g cursor)
        */
        const nextItems = function () {
            var _a, _b, _c;
            if (!(res === null || res === void 0 ? void 0 : res.json)) {
                return null;
            }
            let nextCursorParams = {};
            if (res.json.hasMore || res.json.has_more) {
                let currentCursorField = (((_a = res.json) === null || _a === void 0 ? void 0 : _a.cursor) || ((_b = res.json) === null || _b === void 0 ? void 0 : _b.offset) || ((_c = res.json) === null || _c === void 0 ? void 0 : _c.nextCursor));
                nextCursorParams = Object.assign(Object.assign({}, nextCursorParams), { cursor: currentCursorField, offset: currentCursorField, nextCursor: currentCursorField });
            }
            if (res.json.notice_lists) {
                if (!Array.isArray(res.json.notice_lists) || !res.json.notice_lists.length) {
                    return null;
                }
                let notice_body = res.json.notice_lists[0];
                if (!notice_body.has_more) {
                    return null;
                }
                if (!notice_body.max_time || !notice_body.min_time) {
                    return null;
                }
                nextCursorParams.max_time = notice_body.max_time;
                nextCursorParams.min_time = notice_body.min_time;
            }
            if (res.json.nextCursor) {
                nextCursorParams.nextCursor = res.json.nextCursor;
            }
            if (!Object.keys(nextCursorParams).length) {
                return null;
            }
            return req.self(Object.assign(Object.assign({}, req.params), nextCursorParams));
        };
        /**
        * A method for downloading and saving videos.
        */
        const saveVideo = function (link, path, fetchOptions) {
            var _a, _b;
            return __awaiter(this, void 0, void 0, function* () {
                if (!(res === null || res === void 0 ? void 0 : res.json)) {
                    throw new Error("Failed saving video: Couldn't parse response JSON.");
                }
                let headers = {
                    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36"
                };
                if ((_b = (_a = res.json) === null || _a === void 0 ? void 0 : _a.$other) === null || _b === void 0 ? void 0 : _b.videoLinkHeaders) {
                    headers = Object.assign(Object.assign({}, headers), res.json.$other.videoLinkHeaders);
                }
                const fetch = (yield import("node-fetch")).default;
                return fetch(link, Object.assign({ 'method': 'GET', 'headers': headers }, fetchOptions)).then((res) => {
                    if (!res.ok) {
                        return Promise.reject("Failed downloading video, received invalid response.");
                    }
                    return res.arrayBuffer();
                }).then((arrayBuffer) => {
                    return fs.writeFile(path, Buffer.from(arrayBuffer));
                });
            });
        };
        res['nextItems'] = nextItems;
        res['saveVideo'] = saveVideo;
    };
    return API['set']({
        apiKey: apiKey,
        $options: {
            on_success: on_success
        }
    });
};
TikAPI.default = TikAPI;
if (typeof module !== "undefined" && module.exports) {
    module.exports = TikAPI;
}
export default TikAPI;
